# Doc strings for those API functions not implemented in the library

# Variable block methods

"""
    NLLSsolver.nvars(var)

Return the intrinsic dimensionality (degrees of freedom) of the variable block, `var`. This 
positive integer must remain fixed for the duration of the optimization.

Note that the storage size of `var` can be larger than the intrinsic dimensionality. For 
example, a 3D rotation has only 3 intrinsic dimensions, but a useful representation is a 
9-element 3x3 matrix.

Default implementations of this method exist for types `Number`, `Vector` and 
`StaticVector`.

# Example

For a variable type `Rotation3D` that has three dimensions, the user should define the 
following function:

```julia
    NLLSsolver.nvars(::Rotation3D) = static(3)
```
!!! tip
    If the dimensionality is known at compile time, return a static integer.

!!! note
    Required user-specialized API function.
"""
function nvars end

"""
    update(oldvar, updatevec, start::Int=1)

Update `oldvar` using the `nvars(oldvar)` values in `updatevec::AbstractVector`, starting at 
element `start`, and return the new value. 

The update input `updatevec` may have an autodiff element type, so the variable type and
this method must support a change in internal element datatype.

Default implementations of this method exist for types `Number`, `Vector` and 
`StaticVector`.

# Example

The `update` function for the `Number` abstract type is:

```julia
    NLLSsolver.update(var::Number, updatevec, start=1) = var + updatevec[start]
```

!!! note
    Required user-specialized API function.
"""
function update end

# Cost function methods

"""
    NLLSsolver.ndeps(mycost::AbstractCost)

Return the number of variables that `mycost` depends on. The return value must
be a static integer.

# Example

For a cost function `MyCost <: AbstractCost` that is a function of two variables, the user 
should define the following function:
```julia
    NLLSsolver.ndeps(::MyCost) = static(2)
```

!!! note
    Required user-specialized API function.
"""
function ndeps end


"""
    NLLSsolver.varindices(mycost)

Return a static vector representing the indices of the variables that `mycost` depends on.

# Example

For a cost of type `MyCost <: AbstractCost` that depends on the first and third variables,
the user should define the following function:
```julia
    NLLSsolver.varindices(::MyCost) = SVector(1, 3)
```

!!! note
    Required user-specialized API function.
"""
function varindices end


"""
    NLLSsolver.getvars(mycost, vars)

Return the variables that `mycost` depends on. The return value must be a tuple of
variables.

For good performance, is important that the output variables have concrete types, e.g. not 
`Any`.

# Example

For a problem `MyCost <: AbstractCost` that depends on the first and third variables,
```julia
    NLLSsolver.getvars(::MyCost, vars) = (vars[1], vars[3])
```

!!! tip
    If `vars` is heterogeneous in type, add type-annotations to the specific variables, e.g.
`(vars[1]::Matrix{T}, vars[3]::Vector{T})` for a `MyCost{T}`.

!!! note
    Required user-specialized API function.
"""
function getvars end

# Residual block methods

"""
    NLLSsolver.nres(mycost)

Return the number of residuals that `mycost` generates. The return value must be
an integer, preferably static, and must not change during an optimization.

# Example

For a residual block type `MyResidual <: AbstractResidual` that returns a residual vector
of length three from its `computeresidual` method,
```julia
    NLLSsolver.nres(::MyCost) = static(3)
```

!!! tip
    If the residual length is known at compile time, return a static integer.

!!! note
    Required user-specialized API function.
"""
function nres end


"""
    NLLSsolver.computeresidual(mycost, vars...)

Compute the residuals generated by `mycost` given the variables `vars`. The return
value must be a vector.

# Example

For the Rosenbrock problem with
```julia
struct Rosenbrock <: NLLSsolver.AbstractResidual
    a::Float64
    b::Float64
end
```
the user should define the following function:
```julia
NLLSsolver.computeresidual(res::Rosenbrock, x, y) = SVector(res.a * (1 - x), res.b * (x ^ 2 - y))
```

!!! tip
    If the residual length is known at compile time, return a static vector.

!!! note
    Required user-specialized API function.
"""
function computeresidual end


"""
    NLLSsolver.computeresjac(varflags, mycost, vars...)

Compute the residuals generated by `mycost`, and their derivatives w.r.t. the variables
indicated by the set bits in varflags (the first bit corresponds to the first variable, and
so on) given the variables `vars`. The return values must be a vector and a matrix.

# Example

For the Rosenbrock problem with
```julia
struct Rosenbrock <: NLLSsolver.AbstractResidual
    a::Float64
    b::Float64
end
```
the user should define the following function:
```julia
function NLLSsolver.computeresjac(res::Rosenbrock, x, y)
    res = SVector(res.a * (1 - x), res.b * (x ^ 2 - y))
    jac = SMatrix{2}(-res.a, 0.0, res.b * 2 * x, -res.b)
    return res, jac
end
```

!!! tip
    If the residual length is known at compile time, return a static vector and static
    matrix.

!!! tip
    Try using the default autodiff function before specializing this function for your type.

!!! note
    Optional user-specialized API function.
"""
function computeresjac end
